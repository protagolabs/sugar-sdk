# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/chains.ipynb.

# %% auto 0
__all__ = ['T', 'require_context', 'Chain', 'OPChain', 'BaseChain', 'OPChainSimnet', 'BaseChainSimnet']

# %% ../src/chains.ipynb 3
import asyncio, web3, os
from functools import wraps, reduce
from typing import List, TypeVar, Callable, Optional, Tuple, Dict
from fastcore.utils import patch
from web3 import AsyncWeb3, AsyncHTTPProvider, Account
from web3.eth.async_eth import AsyncContract
from .config import ChainSettings, make_op_chain_settings, make_base_chain_settings
from .helpers import normalize_address, MAX_UINT256, float_to_uint256, apply_slippage, get_future_timestamp
from .abi import sugar, slipstream, price_oracle, router
from .token import Token
from .pool import LiquidityPool
from .price import Price
from .deposit import Deposit
from .helpers import ADDRESS_ZERO, chunk, normalize_address

# %% ../src/chains.ipynb 5
T = TypeVar('T')

def require_context(f: Callable[..., T]) -> Callable[..., T]:
    @wraps(f)
    async def wrapper(self: 'Chain', *args, **kwargs) -> T:
        if not self._in_context: raise RuntimeError("Chain methods can only be accessed within 'async with' block")
        return await f(self, *args, **kwargs)
    return wrapper

class Chain:
    account: Optional[Account]
    web3: AsyncWeb3
    sugar: AsyncContract
    router: AsyncContract

    def __init__(self, settings: ChainSettings):
        self.settings, self._in_context = settings, False

    @property
    def account(self) -> Account: return self.web3.eth.account.from_key(os.getenv("SUGAR_PK"))

    async def __aenter__(self):
        """Async context manager entry"""
        self._in_context = True
        self.web3 = AsyncWeb3(AsyncHTTPProvider(self.settings.rpc_uri))
        self.sugar = self.web3.eth.contract(address=self.settings.sugar_contract_addr, abi=sugar)
        self.slipstream = self.web3.eth.contract(address=self.settings.slipstream_contract_addr, abi=slipstream)
        self.prices = self.web3.eth.contract(address=self.settings.price_oracle_contract_addr, abi=price_oracle)
        self.router = self.web3.eth.contract(address=self.settings.router_contract_addr, abi=router)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        self._in_context = False
        await self.web3.provider.disconnect()
        return None

# %% ../src/chains.ipynb 7
@patch
@require_context
async def get_all_tokens(self: Chain, listed_only: bool = True) -> List[Token]:
    native = Token.make_native_token(self.settings.native_token_symbol, self.settings.wrapped_native_token_addr, self.settings.native_token_decimals)
    tokens = list(map(lambda t: Token.from_tuple(t), await self.sugar.functions.tokens(self.settings.pagination_limit, 0, ADDRESS_ZERO, []).call()))
    return [native] + (list(filter(lambda t: t.listed, tokens)) if listed_only else tokens)
   

# %% ../src/chains.ipynb 9
@patch
@require_context
async def get_pools(self: Chain) -> List[LiquidityPool]:
    pools, offset, limit = [], 0, self.settings.pool_page_size
    tokens = await self.get_all_tokens()
    prices = await self.get_prices(tokens)
    tokens, prices = {t.token_address: t for t in tokens}, {price.token.token_address: price for price in prices}

    while True:
        pools_batch = await self.sugar.functions.all(limit, offset).call()
        pools += pools_batch
        if len(pools_batch) < limit: break
        else: offset += limit

    return list(filter(lambda p: p is not None, map(lambda p: LiquidityPool.from_tuple(p, tokens, prices), pools)))

# %% ../src/chains.ipynb 11
# @cache_in_seconds(ORACLE_PRICES_CACHE_MINUTES * 60)
@patch
async def _get_prices(self: Chain, tokens: Tuple[Token]) -> List[Dict[str, int]]:
    # token_address => normalized rate
    result = {}
    rates = await self.prices.functions.getManyRatesToEthWithCustomConnectors(
        list(map(lambda t: t.wrapped_token_address or t.token_address, tokens)),
        False, # use wrappers
        self.settings.connector_tokens_addrs,
        10 # threshold_filer
    ).call()

    # rates are returned multiplied by eth decimals + the difference in decimals to eth
    # we want them all normalized to 18 decimals
    for cnt, rate in enumerate(rates):
        t, eth_decimals = tokens[cnt], self.settings.native_token_decimals
        if t.decimals == eth_decimals: nr = rate
        elif t.decimals < eth_decimals: nr = rate // (10 ** (eth_decimals - t.decimals))
        else: nr = rate * (10 ** (t.decimals - eth_decimals))
        result[t.token_address] = nr

    return result


@patch
@require_context
async def get_prices(self: Chain, tokens: List[Token]) -> List[Price]:
    """Get prices for tokens in target stable token"""

    eth_decimals = self.settings.native_token_decimals

    batches = await asyncio.gather(
        *map(
            # XX: lists are not cacheable, convert them to tuples so lru cache is happy
            lambda ts: self._get_prices(tuple(ts)),
            list(chunk(tokens, self.settings.price_batch_size)),
        )
    )
    # all rates in EHT: token => rate
    rates_in_eth = reduce(lambda a, b: a | b, batches)
    eth_rate, usd_rate = rates_in_eth[self.settings.native_token_symbol], rates_in_eth[self.settings.stable_token_addr]
    # this gives us the price of 1 eth in usd with 18 decimals precision
    eth_usd_price = (eth_rate * 10 ** eth_decimals) // usd_rate
    # finally convert to prices in terms of stable
    return [Price(token=t, price=(rates_in_eth[t.token_address] * eth_usd_price // 10 ** eth_decimals) / 10 ** eth_decimals) for t in tokens]

# %% ../src/chains.ipynb 13
@patch
@require_context
async def sign_and_send_tx(self: Chain, tx, value: int = 0, wait: bool = True):
    print(f"sign_and_send_tx: {tx} with value: {value}")
    spender = self.account.address
    tx = await tx.build_transaction({ 'from': spender, 'value': value, 'nonce': await self.web3.eth.get_transaction_count(spender) })
    signed_tx = self.account.sign_transaction(tx)
    tx_hash = await self.web3.eth.send_raw_transaction(signed_tx.raw_transaction)
    return await self.web3.eth.wait_for_transaction_receipt(tx_hash) if wait else tx_hash

# %% ../src/chains.ipynb 15
@patch
@require_context
async def set_token_allowance(self: Chain, token: Token, addr: str, amount: int):
    ERC20_ABI = [{
        "name": "approve",
        "type": "function",
        "constant": False,
        "inputs": [{"name": "spender", "type": "address"}, {"name": "amount", "type": "uint256"}],
        "outputs": [{"name": "", "type": "bool"}]
    }]
    token_contract = self.web3.eth.contract(address=token.token_address, abi=ERC20_ABI)
    return await self.sign_and_send_tx(token_contract.functions.approve(addr, amount))

@patch
@require_context
async def check_token_allowance(self: Chain, token: Token, addr: str) -> int:
    ERC20_ABI = [{
        "name": "allowance",
        "type": "function",
        "constant": True,
        "inputs": [{"name": "owner", "type": "address"}, {"name": "spender", "type": "address"}],
        "outputs": [{"name": "", "type": "uint256"}]
    }]
    token_contract = self.web3.eth.contract(address=token.token_address, abi=ERC20_ABI)
    return await token_contract.functions.allowance(self.account.address, addr).call()


# %% ../src/chains.ipynb 17
@patch
@require_context
async def deposit(self: Chain, deposit: Deposit, delay_in_minutes: float = 30, slippage: float = 0.01):
    amount_token0, pool, router_contract_addr = deposit.amount_token0, deposit.pool, self.settings.router_contract_addr
    print(f"gonna deposit {amount_token0} {pool.token0.symbol} into {pool.symbol} from {self.account.address}")
    [token0_amount, token1_amount, _] = await self.router.functions.quoteAddLiquidity(
        pool.token0.token_address,
        pool.token1.token_address,
        pool.is_stable,
        pool.factory,
        float_to_uint256(amount_token0, pool.token0.decimals),
        MAX_UINT256
    ).call()
    print(f"Quote: {pool.token0.symbol} {token0_amount / 10 ** pool.token0.decimals} -> {pool.token1.symbol} {token1_amount / 10 ** pool.token1.decimals}")

    # set up allowance for both tokens
    print(f"setting up allowance for {pool.token0.symbol}")
    await self.set_token_allowance(pool.token0, router_contract_addr, token0_amount)

    print(f"setting up allowance for {pool.token1.symbol}")
    await self.set_token_allowance(pool.token1, router_contract_addr, token1_amount)

    # check allowances
    token0_allowance = await self.check_token_allowance(pool.token0, router_contract_addr)
    token1_allowance = await self.check_token_allowance(pool.token1, router_contract_addr)

    print(f"allowances: {token0_allowance}, {token1_allowance}")

    # adding liquidity

    # if token 0 is native, use addLiquidityETH instead of standard addLiquidity
    if pool.token0.token_address == self.settings.wrapped_native_token_addr:
        params = [
            pool.token1.token_address,
            pool.is_stable,
            token1_amount,
            apply_slippage(token1_amount, slippage),
            apply_slippage(token0_amount, slippage),
            self.account.address,
            get_future_timestamp(delay_in_minutes)
        ]
        print(f"adding liquidity with params: {params}")
        return await self.sign_and_send_tx(self.router.functions.addLiquidityETH(*params), value=token0_amount)
    
    # token 1 is native, use addLiquidityETH instead of standard addLiquidity
    if pool.token1.token_address == self.settings.wrapped_native_token_addr:
        params = [
            pool.token0.token_address,
            pool.is_stable,
            token0_amount,
            apply_slippage(token0_amount, slippage),
            apply_slippage(token1_amount, slippage),
            self.account.address,
            get_future_timestamp(delay_in_minutes)
        ]
        print(f"adding liquidity with params: {params}")
        return await self.sign_and_send_tx(self.router.functions.addLiquidityETH(*params), value=token1_amount)

    params = [
        pool.token0.token_address,
        pool.token1.token_address,
        pool.is_stable,
        token0_amount,
        token1_amount,
        apply_slippage(token0_amount, slippage),
        apply_slippage(token1_amount, slippage),
        self.account.address,
        get_future_timestamp(delay_in_minutes)
    ]

    print(f"adding liquidity with params: {params}")

    return await self.sign_and_send_tx(self.router.functions.addLiquidity(*params))

# %% ../src/chains.ipynb 19
class OPChain(Chain):
    usdc: str = normalize_address("0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85")
    velo: str = normalize_address("0x9560e827aF36c94D2Ac33a39bCE1Fe78631088Db")

    def __init__(self, **kwargs): super().__init__(make_op_chain_settings(**kwargs))


# %% ../src/chains.ipynb 21
class BaseChain(Chain):
    usdc: str = normalize_address("0x833589fcd6edb6e08f4c7c32d4f71b54bda02913")
    aero: str = normalize_address("0x940181a94a35a4569e4529a3cdfb74e38fd98631")

    def __init__(self, **kwargs): super().__init__(make_base_chain_settings(**kwargs))

# %% ../src/chains.ipynb 23
class OPChainSimnet(OPChain):
    def __init__(self,  **kwargs): super().__init__(rpc_uri="http://127.0.0.1:4444", **kwargs)

class BaseChainSimnet(BaseChain):
    def __init__(self,  **kwargs): super().__init__(rpc_uri="http://127.0.0.1:4445", **kwargs)
